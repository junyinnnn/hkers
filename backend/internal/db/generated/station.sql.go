// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: station.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countStations = `-- name: CountStations :one
SELECT COUNT(*) FROM supply_stations
`

func (q *Queries) CountStations(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countStations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVerifiedStations = `-- name: CountVerifiedStations :one
SELECT COUNT(*) FROM supply_stations WHERE is_verified = TRUE
`

func (q *Queries) CountVerifiedStations(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countVerifiedStations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createStation = `-- name: CreateStation :one
INSERT INTO supply_stations (registered_by, location, verification_threshold)
VALUES ($1, ST_SetSRID(ST_MakePoint($2, $3), 4326)::geography, $4)
RETURNING id, registered_by, location, verification_count, verification_threshold, is_verified, created_at, updated_at
`

type CreateStationParams struct {
	RegisteredBy          pgtype.Int4 `json:"registered_by"`
	StMakepoint           interface{} `json:"st_makepoint"`
	StMakepoint_2         interface{} `json:"st_makepoint_2"`
	VerificationThreshold int32       `json:"verification_threshold"`
}

func (q *Queries) CreateStation(ctx context.Context, arg CreateStationParams) (SupplyStation, error) {
	row := q.db.QueryRow(ctx, createStation,
		arg.RegisteredBy,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.VerificationThreshold,
	)
	var i SupplyStation
	err := row.Scan(
		&i.ID,
		&i.RegisteredBy,
		&i.Location,
		&i.VerificationCount,
		&i.VerificationThreshold,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSupplyNeed = `-- name: CreateSupplyNeed :one
INSERT INTO supply_needs (station_id, supply_type, quantity_needed, description, urgency_level)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, station_id, supply_type, quantity_needed, description, urgency_level, created_at, updated_at
`

type CreateSupplyNeedParams struct {
	StationID      pgtype.Int4 `json:"station_id"`
	SupplyType     string      `json:"supply_type"`
	QuantityNeeded pgtype.Int4 `json:"quantity_needed"`
	Description    pgtype.Text `json:"description"`
	UrgencyLevel   pgtype.Text `json:"urgency_level"`
}

func (q *Queries) CreateSupplyNeed(ctx context.Context, arg CreateSupplyNeedParams) (SupplyNeed, error) {
	row := q.db.QueryRow(ctx, createSupplyNeed,
		arg.StationID,
		arg.SupplyType,
		arg.QuantityNeeded,
		arg.Description,
		arg.UrgencyLevel,
	)
	var i SupplyNeed
	err := row.Scan(
		&i.ID,
		&i.StationID,
		&i.SupplyType,
		&i.QuantityNeeded,
		&i.Description,
		&i.UrgencyLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteStation = `-- name: DeleteStation :exec
DELETE FROM supply_stations WHERE id = $1
`

func (q *Queries) DeleteStation(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteStation, id)
	return err
}

const deleteSupplyNeed = `-- name: DeleteSupplyNeed :exec
DELETE FROM supply_needs WHERE id = $1
`

func (q *Queries) DeleteSupplyNeed(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteSupplyNeed, id)
	return err
}

const deleteSupplyNeedsByStation = `-- name: DeleteSupplyNeedsByStation :exec
DELETE FROM supply_needs WHERE station_id = $1
`

func (q *Queries) DeleteSupplyNeedsByStation(ctx context.Context, stationID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteSupplyNeedsByStation, stationID)
	return err
}

const findNearbyStations = `-- name: FindNearbyStations :many
SELECT id, registered_by, location, verification_count, verification_threshold, is_verified, created_at, updated_at,
    ST_Distance(location, ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography) as distance_meters
FROM supply_stations
WHERE ST_DWithin(location, ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography, $3)
ORDER BY distance_meters
LIMIT $4
`

type FindNearbyStationsParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
	StDwithin     interface{} `json:"st_dwithin"`
	Limit         int32       `json:"limit"`
}

type FindNearbyStationsRow struct {
	ID                    int32              `json:"id"`
	RegisteredBy          pgtype.Int4        `json:"registered_by"`
	Location              interface{}        `json:"location"`
	VerificationCount     pgtype.Int4        `json:"verification_count"`
	VerificationThreshold int32              `json:"verification_threshold"`
	IsVerified            pgtype.Bool        `json:"is_verified"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	DistanceMeters        interface{}        `json:"distance_meters"`
}

func (q *Queries) FindNearbyStations(ctx context.Context, arg FindNearbyStationsParams) ([]FindNearbyStationsRow, error) {
	rows, err := q.db.Query(ctx, findNearbyStations,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StDwithin,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindNearbyStationsRow
	for rows.Next() {
		var i FindNearbyStationsRow
		if err := rows.Scan(
			&i.ID,
			&i.RegisteredBy,
			&i.Location,
			&i.VerificationCount,
			&i.VerificationThreshold,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DistanceMeters,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findNearbyVerifiedStations = `-- name: FindNearbyVerifiedStations :many
SELECT id, registered_by, location, verification_count, verification_threshold, is_verified, created_at, updated_at,
    ST_Distance(location, ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography) as distance_meters
FROM supply_stations
WHERE is_verified = TRUE
  AND ST_DWithin(location, ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography, $3)
ORDER BY distance_meters
LIMIT $4
`

type FindNearbyVerifiedStationsParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
	StDwithin     interface{} `json:"st_dwithin"`
	Limit         int32       `json:"limit"`
}

type FindNearbyVerifiedStationsRow struct {
	ID                    int32              `json:"id"`
	RegisteredBy          pgtype.Int4        `json:"registered_by"`
	Location              interface{}        `json:"location"`
	VerificationCount     pgtype.Int4        `json:"verification_count"`
	VerificationThreshold int32              `json:"verification_threshold"`
	IsVerified            pgtype.Bool        `json:"is_verified"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	DistanceMeters        interface{}        `json:"distance_meters"`
}

func (q *Queries) FindNearbyVerifiedStations(ctx context.Context, arg FindNearbyVerifiedStationsParams) ([]FindNearbyVerifiedStationsRow, error) {
	rows, err := q.db.Query(ctx, findNearbyVerifiedStations,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StDwithin,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindNearbyVerifiedStationsRow
	for rows.Next() {
		var i FindNearbyVerifiedStationsRow
		if err := rows.Scan(
			&i.ID,
			&i.RegisteredBy,
			&i.Location,
			&i.VerificationCount,
			&i.VerificationThreshold,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DistanceMeters,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationByID = `-- name: GetStationByID :one


SELECT id, registered_by, location, verification_count, verification_threshold, is_verified, created_at, updated_at FROM supply_stations WHERE id = $1 LIMIT 1
`

// internal/db/queries/station.sql
// SQL queries for supply station operations (used by sqlc)
// ==================== Supply Stations ====================
func (q *Queries) GetStationByID(ctx context.Context, id int32) (SupplyStation, error) {
	row := q.db.QueryRow(ctx, getStationByID, id)
	var i SupplyStation
	err := row.Scan(
		&i.ID,
		&i.RegisteredBy,
		&i.Location,
		&i.VerificationCount,
		&i.VerificationThreshold,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSupplyNeedByID = `-- name: GetSupplyNeedByID :one

SELECT id, station_id, supply_type, quantity_needed, description, urgency_level, created_at, updated_at FROM supply_needs WHERE id = $1 LIMIT 1
`

// ==================== Supply Needs ====================
func (q *Queries) GetSupplyNeedByID(ctx context.Context, id int32) (SupplyNeed, error) {
	row := q.db.QueryRow(ctx, getSupplyNeedByID, id)
	var i SupplyNeed
	err := row.Scan(
		&i.ID,
		&i.StationID,
		&i.SupplyType,
		&i.QuantityNeeded,
		&i.Description,
		&i.UrgencyLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementVerificationCount = `-- name: IncrementVerificationCount :one
UPDATE supply_stations
SET verification_count = verification_count + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, registered_by, location, verification_count, verification_threshold, is_verified, created_at, updated_at
`

func (q *Queries) IncrementVerificationCount(ctx context.Context, id int32) (SupplyStation, error) {
	row := q.db.QueryRow(ctx, incrementVerificationCount, id)
	var i SupplyStation
	err := row.Scan(
		&i.ID,
		&i.RegisteredBy,
		&i.Location,
		&i.VerificationCount,
		&i.VerificationThreshold,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listStations = `-- name: ListStations :many
SELECT id, registered_by, location, verification_count, verification_threshold, is_verified, created_at, updated_at FROM supply_stations
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListStationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListStations(ctx context.Context, arg ListStationsParams) ([]SupplyStation, error) {
	rows, err := q.db.Query(ctx, listStations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SupplyStation
	for rows.Next() {
		var i SupplyStation
		if err := rows.Scan(
			&i.ID,
			&i.RegisteredBy,
			&i.Location,
			&i.VerificationCount,
			&i.VerificationThreshold,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStationsByUser = `-- name: ListStationsByUser :many
SELECT id, registered_by, location, verification_count, verification_threshold, is_verified, created_at, updated_at FROM supply_stations
WHERE registered_by = $1
ORDER BY created_at DESC
`

func (q *Queries) ListStationsByUser(ctx context.Context, registeredBy pgtype.Int4) ([]SupplyStation, error) {
	rows, err := q.db.Query(ctx, listStationsByUser, registeredBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SupplyStation
	for rows.Next() {
		var i SupplyStation
		if err := rows.Scan(
			&i.ID,
			&i.RegisteredBy,
			&i.Location,
			&i.VerificationCount,
			&i.VerificationThreshold,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSupplyNeedsByStation = `-- name: ListSupplyNeedsByStation :many
SELECT id, station_id, supply_type, quantity_needed, description, urgency_level, created_at, updated_at FROM supply_needs
WHERE station_id = $1
ORDER BY urgency_level DESC, created_at DESC
`

func (q *Queries) ListSupplyNeedsByStation(ctx context.Context, stationID pgtype.Int4) ([]SupplyNeed, error) {
	rows, err := q.db.Query(ctx, listSupplyNeedsByStation, stationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SupplyNeed
	for rows.Next() {
		var i SupplyNeed
		if err := rows.Scan(
			&i.ID,
			&i.StationID,
			&i.SupplyType,
			&i.QuantityNeeded,
			&i.Description,
			&i.UrgencyLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnverifiedStations = `-- name: ListUnverifiedStations :many
SELECT id, registered_by, location, verification_count, verification_threshold, is_verified, created_at, updated_at FROM supply_stations
WHERE is_verified = FALSE
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUnverifiedStationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUnverifiedStations(ctx context.Context, arg ListUnverifiedStationsParams) ([]SupplyStation, error) {
	rows, err := q.db.Query(ctx, listUnverifiedStations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SupplyStation
	for rows.Next() {
		var i SupplyStation
		if err := rows.Scan(
			&i.ID,
			&i.RegisteredBy,
			&i.Location,
			&i.VerificationCount,
			&i.VerificationThreshold,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerifiedStations = `-- name: ListVerifiedStations :many
SELECT id, registered_by, location, verification_count, verification_threshold, is_verified, created_at, updated_at FROM supply_stations
WHERE is_verified = TRUE
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListVerifiedStationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListVerifiedStations(ctx context.Context, arg ListVerifiedStationsParams) ([]SupplyStation, error) {
	rows, err := q.db.Query(ctx, listVerifiedStations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SupplyStation
	for rows.Next() {
		var i SupplyStation
		if err := rows.Scan(
			&i.ID,
			&i.RegisteredBy,
			&i.Location,
			&i.VerificationCount,
			&i.VerificationThreshold,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setStationVerified = `-- name: SetStationVerified :one
UPDATE supply_stations
SET is_verified = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, registered_by, location, verification_count, verification_threshold, is_verified, created_at, updated_at
`

type SetStationVerifiedParams struct {
	ID         int32       `json:"id"`
	IsVerified pgtype.Bool `json:"is_verified"`
}

func (q *Queries) SetStationVerified(ctx context.Context, arg SetStationVerifiedParams) (SupplyStation, error) {
	row := q.db.QueryRow(ctx, setStationVerified, arg.ID, arg.IsVerified)
	var i SupplyStation
	err := row.Scan(
		&i.ID,
		&i.RegisteredBy,
		&i.Location,
		&i.VerificationCount,
		&i.VerificationThreshold,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStation = `-- name: UpdateStation :one
UPDATE supply_stations
SET location = ST_SetSRID(ST_MakePoint($2, $3), 4326)::geography,
    verification_threshold = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, registered_by, location, verification_count, verification_threshold, is_verified, created_at, updated_at
`

type UpdateStationParams struct {
	ID                    int32       `json:"id"`
	StMakepoint           interface{} `json:"st_makepoint"`
	StMakepoint_2         interface{} `json:"st_makepoint_2"`
	VerificationThreshold int32       `json:"verification_threshold"`
}

func (q *Queries) UpdateStation(ctx context.Context, arg UpdateStationParams) (SupplyStation, error) {
	row := q.db.QueryRow(ctx, updateStation,
		arg.ID,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.VerificationThreshold,
	)
	var i SupplyStation
	err := row.Scan(
		&i.ID,
		&i.RegisteredBy,
		&i.Location,
		&i.VerificationCount,
		&i.VerificationThreshold,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSupplyNeed = `-- name: UpdateSupplyNeed :one
UPDATE supply_needs
SET supply_type = $2,
    quantity_needed = $3,
    description = $4,
    urgency_level = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, station_id, supply_type, quantity_needed, description, urgency_level, created_at, updated_at
`

type UpdateSupplyNeedParams struct {
	ID             int32       `json:"id"`
	SupplyType     string      `json:"supply_type"`
	QuantityNeeded pgtype.Int4 `json:"quantity_needed"`
	Description    pgtype.Text `json:"description"`
	UrgencyLevel   pgtype.Text `json:"urgency_level"`
}

func (q *Queries) UpdateSupplyNeed(ctx context.Context, arg UpdateSupplyNeedParams) (SupplyNeed, error) {
	row := q.db.QueryRow(ctx, updateSupplyNeed,
		arg.ID,
		arg.SupplyType,
		arg.QuantityNeeded,
		arg.Description,
		arg.UrgencyLevel,
	)
	var i SupplyNeed
	err := row.Scan(
		&i.ID,
		&i.StationID,
		&i.SupplyType,
		&i.QuantityNeeded,
		&i.Description,
		&i.UrgencyLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
