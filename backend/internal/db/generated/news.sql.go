// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: news.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countNews = `-- name: CountNews :one
SELECT COUNT(*) FROM news
`

func (q *Queries) CountNews(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countNews)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNewsBySource = `-- name: CountNewsBySource :one
SELECT COUNT(*) FROM news WHERE source = $1
`

func (q *Queries) CountNewsBySource(ctx context.Context, source string) (int64, error) {
	row := q.db.QueryRow(ctx, countNewsBySource, source)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNews = `-- name: CreateNews :one
INSERT INTO news (source, title, content, url, published_at, relevant_to)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, source, title, content, url, published_at, fetched_at, relevant_to
`

type CreateNewsParams struct {
	Source      string             `json:"source"`
	Title       string             `json:"title"`
	Content     pgtype.Text        `json:"content"`
	Url         pgtype.Text        `json:"url"`
	PublishedAt pgtype.Timestamptz `json:"published_at"`
	RelevantTo  []byte             `json:"relevant_to"`
}

func (q *Queries) CreateNews(ctx context.Context, arg CreateNewsParams) (News, error) {
	row := q.db.QueryRow(ctx, createNews,
		arg.Source,
		arg.Title,
		arg.Content,
		arg.Url,
		arg.PublishedAt,
		arg.RelevantTo,
	)
	var i News
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.Title,
		&i.Content,
		&i.Url,
		&i.PublishedAt,
		&i.FetchedAt,
		&i.RelevantTo,
	)
	return i, err
}

const deleteNews = `-- name: DeleteNews :exec
DELETE FROM news WHERE id = $1
`

func (q *Queries) DeleteNews(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteNews, id)
	return err
}

const deleteOldNews = `-- name: DeleteOldNews :exec
DELETE FROM news WHERE fetched_at < $1
`

func (q *Queries) DeleteOldNews(ctx context.Context, fetchedAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldNews, fetchedAt)
	return err
}

const getLatestNewsBySource = `-- name: GetLatestNewsBySource :one
SELECT id, source, title, content, url, published_at, fetched_at, relevant_to FROM news
WHERE source = $1
ORDER BY published_at DESC NULLS LAST
LIMIT 1
`

func (q *Queries) GetLatestNewsBySource(ctx context.Context, source string) (News, error) {
	row := q.db.QueryRow(ctx, getLatestNewsBySource, source)
	var i News
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.Title,
		&i.Content,
		&i.Url,
		&i.PublishedAt,
		&i.FetchedAt,
		&i.RelevantTo,
	)
	return i, err
}

const getNewsByID = `-- name: GetNewsByID :one

SELECT id, source, title, content, url, published_at, fetched_at, relevant_to FROM news WHERE id = $1 LIMIT 1
`

// internal/db/queries/news.sql
// SQL queries for news operations (used by sqlc)
func (q *Queries) GetNewsByID(ctx context.Context, id int32) (News, error) {
	row := q.db.QueryRow(ctx, getNewsByID, id)
	var i News
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.Title,
		&i.Content,
		&i.Url,
		&i.PublishedAt,
		&i.FetchedAt,
		&i.RelevantTo,
	)
	return i, err
}

const listNews = `-- name: ListNews :many
SELECT id, source, title, content, url, published_at, fetched_at, relevant_to FROM news
ORDER BY published_at DESC NULLS LAST, fetched_at DESC
LIMIT $1 OFFSET $2
`

type ListNewsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListNews(ctx context.Context, arg ListNewsParams) ([]News, error) {
	rows, err := q.db.Query(ctx, listNews, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []News
	for rows.Next() {
		var i News
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.Title,
			&i.Content,
			&i.Url,
			&i.PublishedAt,
			&i.FetchedAt,
			&i.RelevantTo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNewsBySource = `-- name: ListNewsBySource :many
SELECT id, source, title, content, url, published_at, fetched_at, relevant_to FROM news
WHERE source = $1
ORDER BY published_at DESC NULLS LAST, fetched_at DESC
LIMIT $2 OFFSET $3
`

type ListNewsBySourceParams struct {
	Source string `json:"source"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListNewsBySource(ctx context.Context, arg ListNewsBySourceParams) ([]News, error) {
	rows, err := q.db.Query(ctx, listNewsBySource, arg.Source, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []News
	for rows.Next() {
		var i News
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.Title,
			&i.Content,
			&i.Url,
			&i.PublishedAt,
			&i.FetchedAt,
			&i.RelevantTo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentNews = `-- name: ListRecentNews :many
SELECT id, source, title, content, url, published_at, fetched_at, relevant_to FROM news
WHERE published_at >= $1
ORDER BY published_at DESC NULLS LAST
LIMIT $2
`

type ListRecentNewsParams struct {
	PublishedAt pgtype.Timestamptz `json:"published_at"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListRecentNews(ctx context.Context, arg ListRecentNewsParams) ([]News, error) {
	rows, err := q.db.Query(ctx, listRecentNews, arg.PublishedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []News
	for rows.Next() {
		var i News
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.Title,
			&i.Content,
			&i.Url,
			&i.PublishedAt,
			&i.FetchedAt,
			&i.RelevantTo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchNewsByTitle = `-- name: SearchNewsByTitle :many
SELECT id, source, title, content, url, published_at, fetched_at, relevant_to FROM news
WHERE title ILIKE '%' || $1 || '%'
ORDER BY published_at DESC NULLS LAST
LIMIT $2 OFFSET $3
`

type SearchNewsByTitleParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) SearchNewsByTitle(ctx context.Context, arg SearchNewsByTitleParams) ([]News, error) {
	rows, err := q.db.Query(ctx, searchNewsByTitle, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []News
	for rows.Next() {
		var i News
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.Title,
			&i.Content,
			&i.Url,
			&i.PublishedAt,
			&i.FetchedAt,
			&i.RelevantTo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNews = `-- name: UpdateNews :one
UPDATE news
SET source = $2,
    title = $3,
    content = $4,
    url = $5,
    published_at = $6,
    relevant_to = $7
WHERE id = $1
RETURNING id, source, title, content, url, published_at, fetched_at, relevant_to
`

type UpdateNewsParams struct {
	ID          int32              `json:"id"`
	Source      string             `json:"source"`
	Title       string             `json:"title"`
	Content     pgtype.Text        `json:"content"`
	Url         pgtype.Text        `json:"url"`
	PublishedAt pgtype.Timestamptz `json:"published_at"`
	RelevantTo  []byte             `json:"relevant_to"`
}

func (q *Queries) UpdateNews(ctx context.Context, arg UpdateNewsParams) (News, error) {
	row := q.db.QueryRow(ctx, updateNews,
		arg.ID,
		arg.Source,
		arg.Title,
		arg.Content,
		arg.Url,
		arg.PublishedAt,
		arg.RelevantTo,
	)
	var i News
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.Title,
		&i.Content,
		&i.Url,
		&i.PublishedAt,
		&i.FetchedAt,
		&i.RelevantTo,
	)
	return i, err
}
