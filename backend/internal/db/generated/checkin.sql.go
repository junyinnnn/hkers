// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: checkin.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCheckinsByStation = `-- name: CountCheckinsByStation :one
SELECT COUNT(*) FROM checkins WHERE station_id = $1
`

func (q *Queries) CountCheckinsByStation(ctx context.Context, stationID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countCheckinsByStation, stationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCheckin = `-- name: CreateCheckin :one
INSERT INTO checkins (user_id, station_id, checkin_location, notes)
VALUES ($1, $2, ST_SetSRID(ST_MakePoint($3, $4), 4326)::geography, $5)
RETURNING id, user_id, station_id, checkin_location, checkin_time, notes
`

type CreateCheckinParams struct {
	UserID        pgtype.Int4 `json:"user_id"`
	StationID     pgtype.Int4 `json:"station_id"`
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
	Notes         pgtype.Text `json:"notes"`
}

func (q *Queries) CreateCheckin(ctx context.Context, arg CreateCheckinParams) (Checkin, error) {
	row := q.db.QueryRow(ctx, createCheckin,
		arg.UserID,
		arg.StationID,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.Notes,
	)
	var i Checkin
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StationID,
		&i.CheckinLocation,
		&i.CheckinTime,
		&i.Notes,
	)
	return i, err
}

const createCheckinWithoutLocation = `-- name: CreateCheckinWithoutLocation :one
INSERT INTO checkins (user_id, station_id, notes)
VALUES ($1, $2, $3)
RETURNING id, user_id, station_id, checkin_location, checkin_time, notes
`

type CreateCheckinWithoutLocationParams struct {
	UserID    pgtype.Int4 `json:"user_id"`
	StationID pgtype.Int4 `json:"station_id"`
	Notes     pgtype.Text `json:"notes"`
}

func (q *Queries) CreateCheckinWithoutLocation(ctx context.Context, arg CreateCheckinWithoutLocationParams) (Checkin, error) {
	row := q.db.QueryRow(ctx, createCheckinWithoutLocation, arg.UserID, arg.StationID, arg.Notes)
	var i Checkin
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StationID,
		&i.CheckinLocation,
		&i.CheckinTime,
		&i.Notes,
	)
	return i, err
}

const deleteCheckin = `-- name: DeleteCheckin :exec
DELETE FROM checkins WHERE id = $1
`

func (q *Queries) DeleteCheckin(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCheckin, id)
	return err
}

const getCheckinByID = `-- name: GetCheckinByID :one

SELECT id, user_id, station_id, checkin_location, checkin_time, notes FROM checkins WHERE id = $1 LIMIT 1
`

// internal/db/queries/checkin.sql
// SQL queries for check-in operations (used by sqlc)
func (q *Queries) GetCheckinByID(ctx context.Context, id int32) (Checkin, error) {
	row := q.db.QueryRow(ctx, getCheckinByID, id)
	var i Checkin
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StationID,
		&i.CheckinLocation,
		&i.CheckinTime,
		&i.Notes,
	)
	return i, err
}

const getCheckinByUserAndStation = `-- name: GetCheckinByUserAndStation :one
SELECT id, user_id, station_id, checkin_location, checkin_time, notes FROM checkins
WHERE user_id = $1 AND station_id = $2
LIMIT 1
`

type GetCheckinByUserAndStationParams struct {
	UserID    pgtype.Int4 `json:"user_id"`
	StationID pgtype.Int4 `json:"station_id"`
}

func (q *Queries) GetCheckinByUserAndStation(ctx context.Context, arg GetCheckinByUserAndStationParams) (Checkin, error) {
	row := q.db.QueryRow(ctx, getCheckinByUserAndStation, arg.UserID, arg.StationID)
	var i Checkin
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StationID,
		&i.CheckinLocation,
		&i.CheckinTime,
		&i.Notes,
	)
	return i, err
}

const getCheckinWithDetails = `-- name: GetCheckinWithDetails :one
SELECT 
    c.id, c.user_id, c.station_id, c.checkin_location, c.checkin_time, c.notes,
    u.username,
    u.email
FROM checkins c
JOIN users u ON c.user_id = u.id
WHERE c.id = $1
`

type GetCheckinWithDetailsRow struct {
	ID              int32              `json:"id"`
	UserID          pgtype.Int4        `json:"user_id"`
	StationID       pgtype.Int4        `json:"station_id"`
	CheckinLocation interface{}        `json:"checkin_location"`
	CheckinTime     pgtype.Timestamptz `json:"checkin_time"`
	Notes           pgtype.Text        `json:"notes"`
	Username        string             `json:"username"`
	Email           pgtype.Text        `json:"email"`
}

func (q *Queries) GetCheckinWithDetails(ctx context.Context, id int32) (GetCheckinWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getCheckinWithDetails, id)
	var i GetCheckinWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StationID,
		&i.CheckinLocation,
		&i.CheckinTime,
		&i.Notes,
		&i.Username,
		&i.Email,
	)
	return i, err
}

const hasUserCheckedInAtStation = `-- name: HasUserCheckedInAtStation :one
SELECT EXISTS (
    SELECT 1 FROM checkins
    WHERE user_id = $1 AND station_id = $2
) AS has_checked_in
`

type HasUserCheckedInAtStationParams struct {
	UserID    pgtype.Int4 `json:"user_id"`
	StationID pgtype.Int4 `json:"station_id"`
}

func (q *Queries) HasUserCheckedInAtStation(ctx context.Context, arg HasUserCheckedInAtStationParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasUserCheckedInAtStation, arg.UserID, arg.StationID)
	var has_checked_in bool
	err := row.Scan(&has_checked_in)
	return has_checked_in, err
}

const listCheckins = `-- name: ListCheckins :many
SELECT id, user_id, station_id, checkin_location, checkin_time, notes FROM checkins
ORDER BY checkin_time DESC
LIMIT $1 OFFSET $2
`

type ListCheckinsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCheckins(ctx context.Context, arg ListCheckinsParams) ([]Checkin, error) {
	rows, err := q.db.Query(ctx, listCheckins, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Checkin
	for rows.Next() {
		var i Checkin
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StationID,
			&i.CheckinLocation,
			&i.CheckinTime,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCheckinsByStation = `-- name: ListCheckinsByStation :many
SELECT id, user_id, station_id, checkin_location, checkin_time, notes FROM checkins
WHERE station_id = $1
ORDER BY checkin_time DESC
`

func (q *Queries) ListCheckinsByStation(ctx context.Context, stationID pgtype.Int4) ([]Checkin, error) {
	rows, err := q.db.Query(ctx, listCheckinsByStation, stationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Checkin
	for rows.Next() {
		var i Checkin
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StationID,
			&i.CheckinLocation,
			&i.CheckinTime,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCheckinsByUser = `-- name: ListCheckinsByUser :many
SELECT id, user_id, station_id, checkin_location, checkin_time, notes FROM checkins
WHERE user_id = $1
ORDER BY checkin_time DESC
`

func (q *Queries) ListCheckinsByUser(ctx context.Context, userID pgtype.Int4) ([]Checkin, error) {
	rows, err := q.db.Query(ctx, listCheckinsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Checkin
	for rows.Next() {
		var i Checkin
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StationID,
			&i.CheckinLocation,
			&i.CheckinTime,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCheckinsWithUserDetails = `-- name: ListCheckinsWithUserDetails :many
SELECT 
    c.id, c.user_id, c.station_id, c.checkin_location, c.checkin_time, c.notes,
    u.username,
    u.email
FROM checkins c
JOIN users u ON c.user_id = u.id
WHERE c.station_id = $1
ORDER BY c.checkin_time DESC
`

type ListCheckinsWithUserDetailsRow struct {
	ID              int32              `json:"id"`
	UserID          pgtype.Int4        `json:"user_id"`
	StationID       pgtype.Int4        `json:"station_id"`
	CheckinLocation interface{}        `json:"checkin_location"`
	CheckinTime     pgtype.Timestamptz `json:"checkin_time"`
	Notes           pgtype.Text        `json:"notes"`
	Username        string             `json:"username"`
	Email           pgtype.Text        `json:"email"`
}

func (q *Queries) ListCheckinsWithUserDetails(ctx context.Context, stationID pgtype.Int4) ([]ListCheckinsWithUserDetailsRow, error) {
	rows, err := q.db.Query(ctx, listCheckinsWithUserDetails, stationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCheckinsWithUserDetailsRow
	for rows.Next() {
		var i ListCheckinsWithUserDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StationID,
			&i.CheckinLocation,
			&i.CheckinTime,
			&i.Notes,
			&i.Username,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCheckinNotes = `-- name: UpdateCheckinNotes :one
UPDATE checkins
SET notes = $2
WHERE id = $1
RETURNING id, user_id, station_id, checkin_location, checkin_time, notes
`

type UpdateCheckinNotesParams struct {
	ID    int32       `json:"id"`
	Notes pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateCheckinNotes(ctx context.Context, arg UpdateCheckinNotesParams) (Checkin, error) {
	row := q.db.QueryRow(ctx, updateCheckinNotes, arg.ID, arg.Notes)
	var i Checkin
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StationID,
		&i.CheckinLocation,
		&i.CheckinTime,
		&i.Notes,
	)
	return i, err
}
